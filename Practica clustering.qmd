---
title: "Práctica clustering"
author: "Carla Martínez, Patricia Mateu y Margalida Verd"
format: html
editor: visual
---

**Cosas que hay que hacer:**

-   Resumen de los datos para contextualizar
-   ACP
-   Clustering (entiendo yo que habrá que hacerlo de un par de formas)

## Carga de datos de la exposición

```{r, warning=FALSE,message=FALSE,echo=FALSE}
library(tidyverse)

# Cargamos el primer dataframe
global_population = read_csv("Global Population Trends(2016-2022).csv", show_col_types = FALSE) 

# Del segundo dataframe seleccionamos las variables que nos interesan para el estudio

data = read_csv("world_population.csv",show_col_types = FALSE)
world_data <- data %>% 
  select(3,5,14) %>% rename(Country= "Country/Territory", Area_km2 = "Area (km²)")   

# Unimos los dos dataframes y creamos el tibble que usaremos para el estudio
world_population = left_join(global_population,world_data, by = "Country")

world_population %>% 
  glimpse()

```

```{r, warning=FALSE, message=FALSE,echo=FALSE}
world_population <- world_population %>% 
  rename(Pais = "Country", 
         Año = "Year", 
         Pob_total = "Total Population", 
         Pob_urbana = "Urban Population", 
         Pob_rural = "Rural Population", 
         Densidad = "Population Density", 
         Esp_vida = "Life Expectancy", 
         Natalidad = "Birth Rate", 
         Mortalidad = "Death Rate", 
         Fertilidad = "Fertility Rate", 
         Mortalidad_infantil = "Infant Mortality Rate", 
         Crecimiento = "Growth Rate", 
         Continente = "Continent") %>% 
  relocate(Continente, .after = Pais) %>% 
  relocate(Area_km2, .after = Continente) %>% 
  relocate(Mortalidad_infantil, .after = Mortalidad) 

```

```{r, warning=FALSE, message=FALSE,echo=FALSE}
world_population <- world_population %>% 
  mutate(Año = as.character(Año)) %>% 
  mutate(Pob_total = as.numeric(gsub("," , "", Pob_total, fixed = TRUE))) %>%
  mutate(Pob_rural = as.numeric(gsub("," , "", Pob_rural, fixed = TRUE))) %>%
  mutate(Pob_urbana = as.numeric(gsub("," , "", Pob_urbana, fixed = TRUE))) %>% 
  mutate(Densidad = as.integer(Densidad)) %>% 
  mutate(Esp_vida = as.integer(Esp_vida)) %>% 
  mutate(Fertilidad = as.numeric(Fertilidad)) %>% 
  mutate(Mortalidad_infantil = as.numeric(Mortalidad_infantil)) %>% 
  mutate(Crecimiento = as.character(Crecimiento))
  
```

```{r, warning=FALSE, message=FALSE,echo=FALSE}
world_population %>% 
  group_by(Año) %>% 
  summarise_all(funs(sum(is.na(.))))
```

```{r,warning=FALSE,message=FALSE,echo=FALSE}
world_population <- world_population %>% 
  filter(Año == 2018 |Año == 2019 |Año == 2020) 
```

```{r, warning=FALSE,message=FALSE,echo=FALSE}
world_population$Continente[19:21] = "North America"
world_population$Area_km2[19:21] = 442

world_population$Continente[73:75] = "Europe"
world_population$Area_km2[73:75] = 51197

world_population$Continente[97:99] = "Africa"
world_population$Area_km2[97:99] = 4033

world_population$Continente[151:153] = "Africa"
world_population$Area_km2[151:153] = 2344858

world_population$Continente[118:120] = "Europe"
world_population$Area_km2[118:120] = 198

world_population$Continente[277:279] = "Europe"
world_population$Area_km2[277:279] = 572

world_population$Continente[304:306] = "Europe"
world_population$Area_km2[304:306] = 10887

world_population$Continente[310:312] = "Asia"
world_population$Area_km2[310:312] = 199951

world_population$Continente[313:315] = "Asia"
world_population$Area_km2[313:315] = 236800

world_population$Continente[340:342] = "Asia"
world_population$Area_km2[340:342] = 28

world_population$Continente[472:474] = "Africa"
world_population$Area_km2[472:474] = 342000

world_population$Continente[490:492] = "Africa"
world_population$Area_km2[490:492] = 964

world_population$Continente[511:513] = "Europe"
world_population$Area_km2[511:513] = 34

world_population$Continente[514:516] = "Europe"
world_population$Area_km2[514:516] = 49035

world_population$Continente[541:543] = "North America"
world_population$Area_km2[541:543] = 269

world_population$Continente[544:546] = "South America"
world_population$Area_km2[544:546] = 616

world_population$Continente[547:549] = "Europe"
world_population$Area_km2[547:549] = 53

world_population$Continente[550:552] = "North America"
world_population$Area_km2[550:552] = 389

world_population$Continente[565:567] = "Asia"
world_population$Area_km2[565:567] = 185180

world_population$Continente[586:588] = "South America"
world_population$Area_km2[586:588] = 5128

world_population$Continente[598:600] = "North America"
world_population$Area_km2[598:600] = 948

world_population$Continente[604:606] = "Asia"
world_population$Area_km2[604:606] = 83600

world_population$Continente[634:636] = "North America"
world_population$Area_km2[634:636] = 346

world_population$Continente[637:639] = "Asia"
world_population$Area_km2[637:639] = 5860

View(world_population)
```

## Análisis de componentes principales

Realicemos un análisis de componentes principales; empezaremos seleccionando los datos numéricos de nuestra tabla de datos. Recordemos que en el análisis exploratorio, si agrupábamos los datos por la variable `Año`, no había grandes diferencias entre los tres años resultantes: por ello, vamos a considerar solo el año `2019` para llevar a cabo nuestro ACP.

```{r, echo = FALSE, warning=FALSE, message=FALSE}

datos_numericos_pais <- world_population %>% 
  filter(Año == 2019) %>% 
  select(1, 9:13) %>% 
  drop_na() %>% 
  glimpse()

datos_numericos <- world_population %>% 
  filter(Año == 2019) %>% 
  select(9:13) %>% 
  drop_na() %>%
  glimpse()

rownames(datos_numericos) <- datos_numericos_pais$Pais

```

**Comentario Marga: tenemos que determinar si hacemos princomp o prcomp, si escalamos los datos o no y si utilizamos la matriz de covarianzas o correlaciones**

Empezamos ahora con el ACP. Vamos a utilizar la matriz de **correlaciones** y vamos a escalar los datos, debido a que no están tomados con las mismas magnitudes. El resultado que obtenemos es el siguiente:

```{r, echo = FALSE, warning=FALSE, message=FALSE}
library(ggplot2)
library("factoextra")
data.acp=prcomp(datos_numericos, cor = TRUE, scale = TRUE)
data.acp
```

Para entenderlo mejor, obtenemos los valores propios de cada componente:

```{r, echo = FALSE, warning=FALSE, message=FALSE}
get_eigenvalue(data.acp)
```

Observemos que para explicar el 94% de los datos tendríamos que escoger dos componentes principales. Con el siguiente gráfico vamos a determinar si es necesario escoger una más.

```{r, echo = FALSE, warning=FALSE, message=FALSE}
fviz_eig(data.acp, addlabels = TRUE, ylim=c(0,100))
```

Como la pendiente entre la segunda y la tercera componente no es pronunciada, nos quedaremos con las dos primeras componentes principales.

**No se si el grafico siguiente nos va a dar alguna info, porque tenemos 3 componenentes y solo nos representa 2**

En el siguiente gráfico vemos como quedarían representadas cada una de las variables en el círculo de correlación variable.

```{r, echo = FALSE, warning=FALSE, message=FALSE}
fviz_pca_var(data.acp, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE) 
```

Vamos a explicarlo detalladamente:
- Variables correlacionadas positivamente se agrupan
- Las correlacionadas negativamente están posicionadas en cuadrantes opuestas
- La distancia entre variables y el origen mide la calidad de representacioón de las variables, 
- El color de cada variable indica cuan bien representadas están
- La longitud de las flechas nos indica que no todas las varibales tienen influencia en las componentes princpales.

Ahora, veamos si podemos obtener una clasificación de los países por grupos a través de las dos componentes principales.

```{r, echo = FALSE, warning=FALSE, message=FALSE}
fviz_pca_biplot(data.acp, repel = TRUE,
                col.var = "blue", # color para las variables
                col.ind = "#696969"  # color para las observaciones
                )
```

Como vemos, no hay una separación clara de los países en función de las componentes principales. Para poder analizar más en concreto este punto, consideraremos el siguiente gráfico:

```{r, echo = FALSE, warning=FALSE, message=FALSE}

grafico <- fviz_pca_biplot(data.acp, repel = TRUE,
                geom = "point",
                invisible = "var", # color para las variables
                col.ind = "cos2"  # color para las observaciones,
                ) 

  #geom_text(aes(label=datos_numericos_pais$Pais),vjust=-0.2)
```

En él, podemos ver los países coloreados en relación a la calidad de representación en el ACP. Los países representados por azul claro tienen una alta representación, mientras que los países con un azul más oscuro no. 

## Clustering
#outliers: distancia manhattan
#outliers: no hacemos k-means


### k-medoids
```{r}
library(cluster)
library(factoextra)

fviz_nbclust(x = datos_escalados, FUNcluster = pam, method = "wss",
diss = dist(datos_escalados, method = "manhattan")) + 
  geom_vline(xintercept = 4, linetype = 2)
```

```{r}
set.seed(259)
pam_clusters <- pam(x = datos_escalados, k = 4, metric = "manhattan") 
pam_clusters
```

```{r}
medoids <- prcomp(datos_escalados)$x
# Se seleccionan únicamente las proyecciones de las observaciones que son medoids 
medoids <- medoids[rownames(pam_clusters$medoids), c("PC1", "PC2")]
medoids <- as.data.frame(medoids)
# Se emplean los mismos nombres que en el objeto ggplot
colnames(medoids) <- c("x", "y")

# Creación del gráfico
fviz_cluster(object = pam_clusters, data = datos_escalados, ellipse.type = "t", repel = TRUE,show.clust.cent = TRUE) +
theme_bw() +
  geom_point(data = medoids, color = "firebrick", size = 2) + 
  theme(legend.position = "none")
```

### aglomerativo

```{r}
library(tidyverse)
set.seed(101)
hc_completo <- datos_numericos %>% 
  scale() %>% 
  dist(method = "euclidean") %>% 
  hclust(method = "average")
which(cutree(hc_completo, k = 4) == 4)
fviz_dend(x = hc_completo, k = 4, cex = 0.6) + geom_hline(yintercept = 3, linetype = "dashed")
```

```{r}
library(tidyverse)
set.seed(101)
hc_completo <- datos_numericos %>% 
  scale() %>% 
  dist(method = "euclidean") %>% 
  hclust(method = "complete")
fviz_dend(x = hc_completo, k = 4, cex = 0.6) + geom_hline(yintercept = 4., linetype = "dashed")
```

```{r}
library(tidyverse)
set.seed(101)
hc_completo <- datos_numericos %>% 
  scale() %>% 
  dist(method = "euclidean") %>% 
  hclust(method = "ward.D2")
fviz_dend(x = hc_completo, k = 4, cex = 0.6) + geom_hline(yintercept = 10, linetype = "dashed")
```
Veamos a qué cluster pertenece cada país:
```{r}
g <- cutree(hc_completo, k = 4) 
which(g==1)
which(g==2)
which(g==3)
which(g==4)
```



```{r}
fviz_cluster(object = list(data = datos_escalados, cluster = cutree(hc_completo, k = 3)), ellipse.type = "convex",repel = TRUE,
show.clust.cent = TRUE) +
theme_bw()

```


